package main

import (
	"fmt"
	"time"
)

// buf 是通道可以同时容纳的元素（这里是 string）个数
// 1 出于性能考虑建议使用带缓存的通道：

// 使用带缓存的通道可以很轻易成倍提高它的吞吐量，某些场景其性能可以提高至
// 10 倍甚至更多。通过调整通道的容量，甚至可以尝试着更进一步的优化其性能。

// 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。
// 若使用通道的缓冲，你的程序会在 “请求” 激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）
// 。要在首要位置使用无缓冲通道来设计算法，只在不确定的情况下使用缓冲。***非必要不使用带缓冲的通道
// 加了 go 关键字的函数就是协程 异步执行跟 main函数并行执行
func mainbuffer() {
	// 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓清空了。
	// 这里缓冲区如果满了 就会阻塞
	c := make(chan int, 50)
	go func() {
		// 停了15s
		time.Sleep(15 * 1e9)
		x := <-c
		fmt.Println("received", x)
	}()
	fmt.Println("sending", 10)
	c <- 10
	fmt.Println("sent", 10)

	/*
			sending 10
		sent 10
		received 10*/
	time.Sleep(20 * 1e9) //防止协程退出
}
