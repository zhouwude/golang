package main

import "fmt"

// 所以通道的发送 / 接收操作在对方准备好之前是阻塞的：
/*
对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：
	如果 ch 中的数据无人接收，就无法再给通道传入其他数据：
	新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：
	就是通道值被接收时（可以传入变量）。


	默认情况下，通信是同步且无缓冲的：在有接收者接收数据之前，发送不会结束。
	可以想象一个无缓冲的通道在没有空间来保存数据的时候：(不带缓冲的通道是没有存储空间来保存数据的 不需要有接收者)
	必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。
	所以通道的发送 / 接收操作在对方准备好之前是阻塞的：


2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。
默认情况下，通信是同步且无缓冲的：在有接收者接收数据之前，发送不会结束。可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。所以通道的发送 / 接收操作在对方准备好之前是阻塞的：

1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。

2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。


*/
func mainblock() {
	ch1 := make(chan int) //默认是 nil 空channel 类型
	go pump(ch1)          // pump hangs
	// <- ch 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：
	fmt.Println(<-ch1) //0 就一个接收者输出0
	fmt.Println("end")
	//流程 进入jump 协程 <-ch1没有发送者阻塞 end不输出 jump进入循环
	// 输出for--发送者传入值 就一个可用的接受者进入下一个循环阻塞 再也没有接收者了。
	/*for ---
	for ---
	0
	end*/
}

// 开启了协程不在主线程
func pump(ch chan int) {
	// 条件为空则无限循环
	for i := 0; ; i++ {
		fmt.Println("for ---")
		ch <- i //传入值 无限循环 第一次是0 由于没人接受，channel 阻塞无法再传入
	}
}
